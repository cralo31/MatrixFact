sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
library(MatrixFact)
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
library(MatrixFact)
n = 100
X = matrix(rnorm(n^2, 0, 1), n, n)   # Construct a 100-by-100 matrix with random elements
X[X < 0] = 0                         # Truncate all negative values to create a non-negative matix
mode = 1                             # Set mode to 1 for matrix with continuous entries
k = 10                               # Set target factorization rank to be k
iter = 200                           # Set number of iterations to be 200
tol = 1e-5                           # Set convergence threshold to 1e-5
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
X.bin = matrix(rbinom(n^2, 1, runif(n^2, 0.25, 0.75)), n, n)  # Construct a 100-by-100 matrix with binary elements
mode.2 = 2
# Run Binary SONMF with svd initialization
sobin.X = nmf.main(X.bin, mode.2, k, "so_bin", "svd", iter, tol); sobin.X
# Run logNMF with random initialization
lognmf.X = nmf.main(X.bin, mode.2, k, "log_nmf", "random", iter, tol); lognmf.X
G.init[G.init < 0] = eps;
solution = SO_BIN3(X, k, F.init, G.init, tol, iter, tau, factor, step_bin)
X = X.bin
# Convert input X into matrix
X = as.matrix(X)
# Check if any input parameter is invalid and prints either an error or warning message accordingly
error.mess(X, mode, k, method, init, iter, tol, tau, step_bin, step_log, seed)
# Initialize basic parameters
n = nrow(X); p = ncol(X)
eps = 1e-10
F.init = matrix(rnorm(n * k, 0, 1), n, k)
G.init = matrix(rnorm(p * k, 0, 1), p, k)
G.init[G.init < 0] = eps;
solution = SO_BIN3(X, k, F.init, G.init, tol, iter, tau, factor, step_bin)
k
F.init
G.init
tol
iter
tau
factor
factor = 2
step_bin
solution = SO_BIN3(X, k, F.init, G.init, tol, iter, tau, factor, step_bin)
solution
library(MatrixFact)
# Run Binary SONMF with svd initialization
sobin.X = nmf.main(X.bin, mode.2, k, "so_bin", "svd", iter, tol); sobin.X
# Run logNMF with random initialization
lognmf.X = nmf.main(X.bin, mode.2, k, "log_nmf", "random", iter, tol); lognmf.X
# Run Binary SONMF with svd initialization
sobin.X = nmf.main(X.bin, mode.2, k, "so_bin", "svd", iter, tol); sobin.X
# Run logNMF with random initialization
lognmf.X = nmf.main(X.bin, mode.2, k, "log_nmf", "random", iter, tol); lognmf.X
library(MatrixFact)
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
library(MatrixFact)
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
library(MatrixFact)
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
n = 100
X = matrix(rnorm(n^2, 0, 1), n, n)   # Construct a 100-by-100 matrix with random elements
X[X < 0] = 0                         # Truncate all negative values to create a non-negative matix
mode = 1                             # Set mode to 1 for matrix with continuous entries
k = 10                               # Set target factorization rank to be k
iter = 200                           # Set number of iterations to be 200
tol = 1e-5
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
library(MatrixFact)
roxygenize()
library(roxygen2)
roxygenize("MatrixFact")
roxygenize()
roxygenize()
?nmf.main
library(MatrixFact)
roxygenize()
?nmf.main
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
library(MatrixFact)
n = 100
X = matrix(rnorm(n^2, 0, 1), n, n)   # Construct a 100-by-100 matrix with random elements
X[X < 0] = 0                         # Truncate all negative values to create a non-negative matix
mode = 1                             # Set mode to 1 for matrix with continuous entries
k = 10                               # Set target factorization rank to be k
iter = 200                           # Set number of iterations to be 200
tol = 1e-5                           # Set convergence threshold to 1e-5
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
X.bin = matrix(rbinom(n^2, 1, runif(n^2, 0.25, 0.75)), n, n)  # Construct a 100-by-100 matrix with binary elements
mode.2 = 2
# Run Binary SONMF with svd initialization
sobin.X = nmf.main(X.bin, mode.2, k, "so_bin", "svd", iter, tol); sobin.X
# Run logNMF with random initialization
lognmf.X = nmf.main(X.bin, mode.2, k, "log_nmf", "random", iter, tol); lognmf.X
build_vignettes()
library(MatrixFact)
library(MatrixFact)
build()
devtools::use_vignette("introduction")
install_github("cronshells/MatrixFact")
remove.packages("MatrixFact")
remove.packages("matfact")
library(MatrixFact)
library(MatrixFact)
library(MatrixFact)
library(MatrixFact)
remove.packages("matfact")
remove.packages("MatrixFact")
library(MatrixFact)
devtools::install_github("cronshells/MatrixFact")
document()
library(MatrixFact)
document()
document()
library(MatrixFact)
library(MatrixFact)
library(MatrixFact)
library(MatrixFact)
library(MatrixFact)
n = 100
X = matrix(rnorm(n^2, 0, 1), n, n)   # Construct a 100-by-100 matrix with random elements
X[X < 0] = 0                         # Truncate all negative values to create a non-negative matix
mode = 1                             # Set mode to 1 for matrix with continuous entries
k = 10                               # Set target factorization rank to be k
iter = 200                           # Set number of iterations to be 200
tol = 1e-5                           # Set convergence threshold to 1e-5
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
library(MatrixFact)
document()
library(MatrixFact)
library(MatrixFact)
# Run SONMF with svd initialization
sonmf.X = nmf.main(X, mode, k, "sonmf", "svd", iter, tol); sonmf.X
# Run NMF with random initialization
nmf.X = nmf.main(X, mode, k, "nmf", "random", iter, tol); nmf.X
# Run ONMF with random initialization
onmf.X = nmf.main(X, mode, k, "onmf", "random", iter, tol); onmf.X
# Run Semi-NMF with kmeans initialization
semi.X = nmf.main(X, mode, k, "semi", "kmeans", iter, tol); semi.X
X.bin = matrix(rbinom(n^2, 1, runif(n^2, 0.25, 0.75)), n, n)  # Construct a 100-by-100 matrix with binary elements
mode.2 = 2
# Run Binary SONMF with svd initialization
sobin.X = nmf.main(X.bin, mode.2, k, "so_bin", "svd", iter, tol); sobin.X
# Run logNMF with random initialization
lognmf.X = nmf.main(X.bin, mode.2, k, "log_nmf", "random", iter, tol); lognmf.X
# Run Binary SONMF with svd initialization
sobin.X = nmf.main(X.bin, mode.2, k, "so_bin", "svd", iter, tol); sobin.X
# Run logNMF with random initialization
lognmf.X = nmf.main(X.bin, mode.2, k, "log_nmf", "random", iter, tol); lognmf.X
document()
build()
document()
?nmf.main
system("R CMD Rd2pdf .")
library(MatrixFact)
library(MatrixFact)
document(\)
document()
?nmf.main
library(MatrixFact)
library(MatrixFact)
document()
?nmf.main
library(MatrixFact)
library(MatrixFact)
document()
?nmf.main
document()
?nmf.main
library(MatrixFact)
?nmf.main
system("R CMD Rd2pdf MatrixFact")
system("R CMD Rd2pdf .")
system("R CMD Rd2pdf .")
system("R CMD Rd2pdf .")
system("R CMD Rd2pdf .")
build()
library(MatrixFact)
?nmf.main
library(MatrixFact)
devtools::document()
library(MatrixFact)
?bin.test
library(MatrixFact)
devtools::document()
library(MatrixFact)
library(MatrixFact)
library(MatrixFact)
devtools::document()
library(MatrixFact)
devtools::document()
library(MatrixFact)
bin.test
load("C:/Users/cronshells/Dropbox/Jack/JASA/code/cont_temp.RData")
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/code/plot")
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, k, file) {
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
plot(res$bin[,2], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(res$log[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 6)
lines(res$log[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 6)
lines(res$log[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 6)
abline(h = res$summary[1], col = "purple")
}
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, k, file) {
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res + 1)
plot(log.res$bin[,2], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res$log[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 3)
lines(log.res$log[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 4)
lines(log.res$log[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1)
plot.fun(res.1, 10, "1_10")
plot.fun(res.1$res.10, 10, "1_10")
res = res.1$res.10
log.res = log(res + 1)
log.res
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, k, file) {
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res + 1)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "black", pch = 10, type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "black", pch = 10, type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1$res.10, 10, "1_10")
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lgo.res[,1]
log.res[,1]
k = 10
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
plot.new()
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 3)
library(Cairo)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
load("C:/Users/cronshells/Dropbox/Jack/JASA/code/cont_temp.RData")
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, k, file) {
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res + 1)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "black", pch = 10, type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "black", pch = 10, type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1$res.10, 10, "1_10")
res = res.1$res.10
log.res = log(res + 1)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 3)
dev.off
dev.off()
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", pch = 10, type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "black", pch = 10, type = "l", lwd = 2, lty = 4)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
log.res = log(res + 1)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "")
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
yrange = c(0, 2)
plot(log.res[,1], col = "red", type = "l", lty = 1, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
plot(log.res[,1], col = "red", type = "l", lty = 2, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, k, file, yrange) {
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res + 1)
plot(log.res[,1], col = "red", type = "l", lty = 2, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1$res.10, 10, "1_10", c(0, 1.7))
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, index, k, file, yrange) {
res.temp = res[[index]]
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res.temp + 1)
plot(log.res[,1], col = "red", type = "l", lty = 2, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1$res.10, 10, "1_10", c(0, 1.7))
plot.fun(res.1$res.10, 1, 10, "1_10", c(0, 1.7))
plot.fun(res.1, 1, 10, "1_10", c(0, 1.7))
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/code/plot")
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, index, k, file, yrange) {
res.temp = res[[index]]
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res.temp + 1)
plot(log.res[,1], col = "red", type = "l", lty = 2, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1, 1, 10, "1_10", c(0, 1.7))
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/plot")
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, index, k, file, yrange) {
res.temp = res[[index]]
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res.temp + 1)
plot(log.res[,1], col = "red", type = "l", lty = 2, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1, 1, 10, "1_10", c(0, 1.7))
getwd()
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/plot")
load("C:/Users/cronshells/Dropbox/Jack/JASA/code/cont_temp.RData")
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/plot")
# Plot the log of the normalized residual for better visibility
plot.fun = function(res, index, k, file, yrange) {
res.temp = res[[index]]
# Use the Cairo package for better plot resolution
png(filename=paste0(file, ".png"),
type="cairo",
units="in",
width=5,
height=4,
pointsize=12,
res=288)
log.res = log(res.temp + 1)
plot(log.res[,1], col = "red", type = "l", lty = 2, lwd = 2, main = paste0("K = ", k), xlab = "Iterations", ylab = "", ylim = yrange)
lines(log.res[,2], col = "black", type = "l", lwd = 2, lty = 3)
lines(log.res[,3], col = "blue", type = "l", lwd = 2, lty = 4)
lines(log.res[,4], col = "green", type = "l", lwd = 2, lty = 5)
abline(h = log(res$summary[1] + 1), col = "purple")
legend("topright", legend = c("SONMF", "NMF", "ONMF", "Semi", "True Error"),
col = c("red", "green", "blue", "black", "purple"), lty = c(2, 5, 4, 3, 1))
}
plot.fun(res.1, 1, 10, "1_10", c(0, 1.7))
getwd()
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/plot")
# Set directory for the plots
setwd("C:/Users/cronshells/Dropbox/Jack/JASA/plot")
